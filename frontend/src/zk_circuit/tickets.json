{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","hash":"13453435907472809318","abi":{"parameters":[{"name":"md","type":{"kind":"struct","path":"TicketMetadata","fields":[{"name":"origin","type":{"kind":"field"}},{"name":"destination","type":{"kind":"field"}},{"name":"date","type":{"kind":"field"}},{"name":"class","type":{"kind":"field"}},{"name":"product_type","type":{"kind":"field"}},{"name":"ticket_id","type":{"kind":"field"}}]},"visibility":"private"},{"name":"C","type":{"kind":"field"},"visibility":"private"},{"name":"N","type":{"kind":"field"},"visibility":"private"},{"name":"pk_TA","type":{"kind":"field"},"visibility":"private"},{"name":"sig","type":{"kind":"field"},"visibility":"private"},{"name":"s","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use poseidon::poseidon::bn254::{hash_1, hash_2};\n\npub struct TicketMetadata {\n    origin: Field,\n    destination: Field,\n    date: Field,\n    class: Field,\n    product_type: Field,\n    ticket_id: Field,\n}\n\npub fn compute_commitment(md: TicketMetadata, s: Field) -> Field {\n    hash_2([md.ticket_id, s])\n}\n\npub fn compute_nullifier(s: Field) -> Field {\n    hash_1([s])\n}\n\nfn verify_signature_stub(_msg: [Field; 7], _pk: Field, _sig: Field) -> bool {\n    true\n}\n\npub fn main(\n    md: TicketMetadata,\n    C: Field,\n    N: Field,\n    pk_TA: Field,\n    sig: Field,\n    s: Field,\n) {\n    let C_calc = compute_commitment(md, s);\n    assert(C == C_calc);\n\n    let N_calc = compute_nullifier(s);\n    assert(N == N_calc);\n\n    let msg: [Field; 7] = [\n        md.origin,\n        md.destination,\n        md.date,\n        md.class,\n        md.product_type,\n        md.ticket_id,\n        C,\n    ];\n\n    let is_valid = verify_signature_stub(msg, pk_TA, sig);\n    assert(is_valid);\n}\n\n#[test]\nfn test_main() {\n    let md = TicketMetadata {\n        origin: 1,\n        destination: 2,\n        date: 3,\n        class: 4,\n        product_type: 5,\n        ticket_id: 6,\n    };\n\n    let s = 7;\n\n    let C = compute_commitment(md, s);\n    let N = compute_nullifier(s);\n\n    let pk_TA = 11;\n    let sig = 12;\n\n    main(md, C, N, pk_TA, sig, s);\n}\n","path":"/Users/kal/Documents/Projects/Competitions/LauzHack/AZKT-System-/tickets/src/main.nr"},"54":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/kal/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"55":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/Users/kal/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"56":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/kal/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}